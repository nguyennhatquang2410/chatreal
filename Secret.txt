<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Li√™n Qu√¢n Mini - Pro AI Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Joystick */
        #joystickArea {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 130px;
            height: 130px;
            z-index: 100;
        }

        #joystickBase {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.15);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            left: 5px;
            top: 5px;
        }

        #joystickStick {
            position: absolute;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(200,200,200,0.8) 100%);
            border-radius: 50%;
            left: 40px;
            top: 40px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        /* Skill buttons */
        #skillArea {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
        }

        .skill-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid #ffd700;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px #000;
            position: absolute;
            cursor: pointer;
            background: rgba(0,0,0,0.5);
        }

        .skill-btn:active {
            transform: scale(0.9);
            filter: brightness(1.2);
        }

        .skill-btn.cooldown {
            filter: grayscale(100%) brightness(0.5);
        }

        #skill1 { right: 130px; bottom: 50px; background: linear-gradient(135deg, #4a90d9, #2c5aa0); }
        #skill2 { right: 75px; bottom: 110px; background: linear-gradient(135deg, #9b59b6, #6c3483); }
        #skill3 { right: 10px; bottom: 50px; background: linear-gradient(135deg, #e74c3c, #922b21); width: 70px; height: 70px; font-size: 18px; }

        #attackBtn {
            background: linear-gradient(135deg, #f39c12 0%, #d68910 100%);
            width: 85px;
            height: 85px;
            right: 60px;
            bottom: -10px;
            border-color: #fff;
            font-size: 32px;
        }

        /* Ph·ª• tr·ª£ */
        .talent-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 1px solid #fff;
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: #fff;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        #healBtn { right: 210px; bottom: 30px; }
        #flashBtn { right: 10px; bottom: 135px; }

        /* Status UI */
        #statusUI {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 100;
        }

        #levelText {
            color: #ffd700;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            margin-bottom: 5px;
        }

        .bar-bg {
            width: 140px;
            height: 16px;
            background: rgba(0,0,0,0.7);
            border-radius: 8px;
            margin-bottom: 4px;
            overflow: hidden;
            border: 1px solid #333;
        }

        #hpFill { width: 100%; height: 100%; background: linear-gradient(to right, #4caf50, #8bc34a); transition: width 0.2s; }
        #mpFill { width: 100%; height: 100%; background: linear-gradient(to right, #2196f3, #03a9f4); transition: width 0.2s; }
        #expFill { width: 0%; height: 100%; background: linear-gradient(to right, #9c27b0, #e91e63); transition: width 0.2s; }

        #goldText {
            color: #ffd700;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            margin-top: 5px;
        }

        #scoreUI {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 5px 20px;
            border-radius: 20px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #blueScore { color: #4a90d9; font-size: 20px; font-weight: bold; }
        #redScore { color: #e74c3c; font-size: 20px; font-weight: bold; }

        /* Minimap */
        #minimap {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 100px;
            height: 100px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #ffd700;
            border-radius: 5px;
            z-index: 100;
        }

        /* Kill Announcement */
        #announcement {
            position: fixed;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 30px;
            font-weight: bold;
            text-shadow: 0 0 10px #000;
            z-index: 200;
            pointer-events: none;
            text-align: center;
        }

        #messages {
            position: fixed;
            top: 120px;
            right: 10px;
            z-index: 100;
            text-align: right;
        }

        .msg {
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 4px 10px;
            margin-bottom: 4px;
            border-radius: 4px;
            font-size: 12px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* Character Select */
        #charSelect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .heroGrid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            padding: 10px;
            max-width: 320px;
        }

        .heroCard {
            width: 85px;
            height: 100px;
            background: rgba(255,255,255,0.1);
            border: 3px solid #444;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .heroCard.selected {
            border-color: #ffd700;
            background: rgba(255,215,0,0.2);
            transform: scale(1.05);
        }

        .heroIcon { font-size: 36px; }
        .heroName { color: #fff; font-size: 11px; }

        #playBtn {
            margin-top: 25px;
            padding: 12px 50px;
            font-size: 18px;
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            border: none;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
        }

        /* Game Over */
        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        #restartBtn {
            padding: 12px 40px;
            font-size: 18px;
            background: #ffd700;
            border: none;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="charSelect">
        <h1 style="color:#ffd700; margin-bottom:10px;">‚öîÔ∏è LI√äN QU√ÇN MINI ‚öîÔ∏è</h1>
        <p style="color:#aaa; margin-bottom:20px;">Ch·ªçn t∆∞·ªõng c·ªßa b·∫°n</p>
        <div class="heroGrid">
            <div class="heroCard selected" data-hero="warrior"><div class="heroIcon">‚öîÔ∏è</div><div class="heroName">Chi·∫øn Binh</div></div>
            <div class="heroCard" data-hero="mage"><div class="heroIcon">üîÆ</div><div class="heroName">Ph√°p S∆∞</div></div>
            <div class="heroCard" data-hero="archer"><div class="heroIcon">üèπ</div><div class="heroName">X·∫° Th·ªß</div></div>
            <div class="heroCard" data-hero="assassin"><div class="heroIcon">üó°Ô∏è</div><div class="heroName">S√°t Th·ªß</div></div>
            <div class="heroCard" data-hero="tank"><div class="heroIcon">üõ°Ô∏è</div><div class="heroName">ƒê·ª° ƒê√≤n</div></div>
            <div class="heroCard" data-hero="support"><div class="heroIcon">üíö</div><div class="heroName">H·ªó Tr·ª£</div></div>
        </div>
        <button id="playBtn">V√ÄO TR·∫¨N</button>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="announcement"></div>

    <div id="statusUI">
        <div id="levelText">Lv.1</div>
        <div class="bar-bg"><div id="hpFill"></div></div>
        <div class="bar-bg"><div id="mpFill"></div></div>
        <div class="bar-bg"><div id="expFill"></div></div>
        <div id="goldText">üí∞ 0</div>
    </div>

    <div id="scoreUI">
        <span id="blueScore">0</span>
        <span style="color:#fff">:</span>
        <span id="redScore">0</span>
    </div>

    <div id="minimap">
        <canvas id="minimapCanvas" width="100" height="100"></canvas>
    </div>

    <div id="messages"></div>

    <div id="joystickArea">
        <div id="joystickBase"></div>
        <div id="joystickStick"></div>
    </div>

    <div id="skillArea">
        <div id="skill1" class="skill-btn">CHI√äU 1</div>
        <div id="skill2" class="skill-btn">CHI√äU 2</div>
        <div id="skill3" class="skill-btn">ULTI</div>
        <div id="attackBtn" class="skill-btn">‚öî</div>
        <div id="healBtn" class="talent-btn">H·ªíI M√ÅU</div>
        <div id="flashBtn" class="talent-btn">T·ªêC BI·∫æN</div>
    </div>

    <div id="gameOver">
        <h1 id="resultTitle">CHI·∫æN TH·∫ÆNG!</h1>
        <p id="resultStats" style="color:#fff; margin: 15px 0;"></p>
        <button id="restartBtn">CH∆†I L·∫†I</button>
    </div>

    <script>
        // ==================== CONFIG & SETUP ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');

        const MAP_W = 3500;
        const MAP_H = 3500;

        const HEROES = {
            warrior:  { hp: 1200, mp: 400, atk: 110, def: 50, spd: 4.5, range: 65,  color: '#e74c3c', icon: '‚öîÔ∏è' },
            mage:     { hp: 750,  mp: 800, atk: 160, def: 25, spd: 3.5, range: 220, color: '#9b59b6', icon: 'üîÆ' },
            archer:   { hp: 800,  mp: 500, atk: 140, def: 30, spd: 4.0, range: 280, color: '#3498db', icon: 'üèπ' },
            assassin: { hp: 850,  mp: 400, atk: 185, def: 35, spd: 5.5, range: 55,  color: '#34495e', icon: 'üó°Ô∏è' },
            tank:     { hp: 1800, mp: 300, atk: 75,  def: 90, spd: 3.2, range: 55,  color: '#f39c12', icon: 'üõ°Ô∏è' },
            support:  { hp: 950,  mp: 700, atk: 80,  def: 40, spd: 3.8, range: 180, color: '#2ecc71', icon: 'üíö' }
        };

        let selectedHero = 'warrior';
        let gameRunning = false;
        let gameOver = false;
        let player = null;
        let camera = { x: 0, y: 0 };
        let enemies = [], minions = [], towers = [], bullets = [], effects = [], monsters = [];
        let gold = 0, kills = 0, deaths = 0, blueScore = 0, redScore = 0;
        let skillCD = [0, 0, 0];
        let talentCD = { heal: 0, flash: 0 };
        const SKILL_MAX_CD = [6, 10, 30];
        const SKILL_MANA = [50, 80, 150];
        let joyActive = false, joyDX = 0, joyDY = 0;
        let lastTime = 0;
        let doubleKillTimer = 0;
        let killCountInTime = 0;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // ==================== INTERACTION ====================
        document.querySelectorAll('.heroCard').forEach(card => {
            card.addEventListener('click', function() {
                document.querySelectorAll('.heroCard').forEach(c => c.classList.remove('selected'));
                this.classList.add('selected');
                selectedHero = this.dataset.hero;
            });
        });

        document.getElementById('playBtn').addEventListener('click', () => {
            document.getElementById('charSelect').style.display = 'none';
            startGame();
        });

        document.getElementById('restartBtn').addEventListener('click', () => location.reload());

        // ==================== GAME CORE ====================
        function startGame() {
            gameRunning = true;
            const stats = HEROES[selectedHero];
            player = {
                x: 300, y: MAP_H - 300,
                hp: stats.hp, maxHp: stats.hp, mp: stats.mp, maxMp: stats.mp,
                atk: stats.atk, def: stats.def, spd: stats.spd, range: stats.range,
                color: stats.color, icon: stats.icon,
                level: 1, exp: 0, expNext: 100, radius: 22, atkCD: 0, team: 'blue'
            };

            // Tr·ª• v√† Nh√† ch√≠nh
            towers = [
                // Team Xanh
                { x: 600, y: MAP_H - 600, hp: 2000, maxHp: 2000, team: 'blue', range: 350, atk: 180, cd: 0 },
                { x: 1200, y: MAP_H - 1200, hp: 3000, maxHp: 3000, team: 'blue', range: 350, atk: 220, cd: 0 },
                { x: 250, y: MAP_H - 250, hp: 6000, maxHp: 6000, team: 'blue', range: 450, atk: 350, cd: 0, nexus: true },
                // Team ƒê·ªè
                { x: MAP_W - 600, y: 600, hp: 2000, maxHp: 2000, team: 'red', range: 350, atk: 180, cd: 0 },
                { x: MAP_W - 1200, y: 1200, hp: 3000, maxHp: 3000, team: 'red', range: 350, atk: 220, cd: 0 },
                { x: MAP_W - 250, y: 250, hp: 6000, maxHp: 6000, team: 'red', range: 450, atk: 350, cd: 0, nexus: true }
            ];

            // T∆∞·ªõng ƒë·ªãch
            const enemyTypes = ['warrior', 'mage', 'archer'];
            enemyTypes.forEach((type, i) => {
                const s = HEROES[type];
                enemies.push({
                    x: MAP_W - 400 - (i*150), y: 400 + (i*150),
                    hp: s.hp, maxHp: s.hp, atk: s.atk, def: s.def, spd: s.spd * 0.9, range: s.range,
                    color: s.color, icon: s.icon, radius: 22, team: 'red', cd: 0, alive: true, respawn: 0
                });
            });

            // Qu√°i r·ª´ng
            monsters = [
                { x: 1000, y: 1000, hp: 1500, maxHp: 1500, type: 'blue_buff', icon: 'üåÄ' },
                { x: MAP_W - 1000, y: MAP_H - 1000, hp: 1500, maxHp: 1500, type: 'red_buff', icon: 'üî•' }
            ];

            spawnMinions();
            setInterval(() => { if(gameRunning) spawnMinions(); }, 30000);
            requestAnimationFrame(gameLoop);
        }

        function spawnMinions() {
            const blueSpawn = { x: 400, y: MAP_H - 400 };
            const redSpawn = { x: MAP_W - 400, y: 400 };
            for(let i=0; i<3; i++) {
                minions.push({ x: blueSpawn.x + i*30, y: blueSpawn.y - i*30, hp: 500, maxHp: 500, atk: 40, spd: 2, team: 'blue', range: 50, radius: 15, cd: 0 });
                minions.push({ x: redSpawn.x - i*30, y: redSpawn.y + i*30, hp: 500, maxHp: 500, atk: 40, spd: 2, team: 'red', range: 50, radius: 15, cd: 0 });
            }
        }

        // ==================== CONTROLS ====================
        const joystickArea = document.getElementById('joystickArea');
        const joystickStick = document.getElementById('joystickStick');

        joystickArea.addEventListener('touchstart', (e) => { e.preventDefault(); joyActive = true; moveJoy(e); });
        joystickArea.addEventListener('touchmove', (e) => { if(joyActive) moveJoy(e); });
        joystickArea.addEventListener('touchend', () => { 
            joyActive = false; joyDX = 0; joyDY = 0;
            joystickStick.style.left = '35px'; joystickStick.style.top = '35px';
        });

        function moveJoy(e) {
            const rect = joystickArea.getBoundingClientRect();
            const cx = rect.left + 65, cy = rect.top + 65;
            const touch = e.touches[0];
            let dx = touch.clientX - cx, dy = touch.clientY - cy;
            const dist = Math.sqrt(dx*dx + dy*dy), maxD = 40;
            if (dist > maxD) { dx *= maxD/dist; dy *= maxD/dist; }
            joystickStick.style.left = (35 + dx) + 'px';
            joystickStick.style.top = (35 + dy) + 'px';
            joyDX = dx/maxD; joyDY = dy/maxD;
        }

        document.getElementById('skill1').addEventListener('touchstart', (e) => { e.preventDefault(); useSkill(0); });
        document.getElementById('skill2').addEventListener('touchstart', (e) => { e.preventDefault(); useSkill(1); });
        document.getElementById('skill3').addEventListener('touchstart', (e) => { e.preventDefault(); useSkill(2); });
        document.getElementById('attackBtn').addEventListener('touchstart', (e) => { e.preventDefault(); doAttack(); });
        document.getElementById('healBtn').addEventListener('touchstart', (e) => { e.preventDefault(); useHeal(); });
        document.getElementById('flashBtn').addEventListener('touchstart', (e) => { e.preventDefault(); useFlash(); });

        // ==================== SKILLS & TALENTS ====================
        function useSkill(idx) {
            if (!player || skillCD[idx] > 0 || player.mp < SKILL_MANA[idx]) return;
            player.mp -= SKILL_MANA[idx];
            skillCD[idx] = SKILL_MAX_CD[idx];
            
            if (idx === 0) { // Chi√™u 1: L∆∞·ªõt v√† s√°t th∆∞∆°ng
                const angle = Math.atan2(joyDY, joyDX) || 0;
                player.x += Math.cos(angle) * 150;
                player.y += Math.sin(angle) * 150;
                addEffect(player.x, player.y, 80, player.color, 0.4);
            } else if (idx === 1) { // Chi√™u 2: Kh·ªëng ch·∫ø/AOE
                addEffect(player.x, player.y, 180, '#fff', 0.6);
                getAllEnemies('red').forEach(e => {
                    if (getDist(player.x, player.y, e.x, e.y) < 180) doDamage(e, player.atk * 2);
                });
            } else if (idx === 2) { // Ulti
                announce("ULTIMATE READY!");
                addEffect(player.x, player.y, 300, '#ffd700', 1.0);
                getAllEnemies('red').forEach(e => {
                    if (getDist(player.x, player.y, e.x, e.y) < 300) doDamage(e, player.atk * 4);
                });
            }
        }

        function useHeal() {
            if (talentCD.heal > 0) return;
            player.hp = Math.min(player.maxHp, player.hp + player.maxHp * 0.15);
            talentCD.heal = 60;
            addEffect(player.x, player.y, 100, '#2ecc71', 0.5);
        }

        function useFlash() {
            if (talentCD.flash > 0) return;
            const angle = Math.atan2(joyDY, joyDX) || 0;
            player.x += Math.cos(angle) * 250;
            player.y += Math.sin(angle) * 250;
            talentCD.flash = 120;
            addEffect(player.x, player.y, 50, '#fff', 0.3);
        }

        function doAttack() {
            if (!player || player.atkCD > 0) return;
            const target = findNearestEnemy(player.x, player.y, 'red', player.range + 100);
            if (!target) return;
            player.atkCD = 0.5;
            if (player.range > 100) {
                bullets.push({ x: player.x, y: player.y, tx: target.x, ty: target.y, spd: 15, dmg: player.atk, team: 'blue', r: 6, color: player.color });
            } else {
                doDamage(target, player.atk);
                addEffect(target.x, target.y, 30, '#fff', 0.2);
            }
        }

        // ==================== LOGIC ====================
        function update(dt) {
            if (!player || gameOver) return;

            // Di chuy·ªÉn
            player.x += joyDX * player.spd;
            player.y += joyDY * player.spd;
            player.x = Math.max(50, Math.min(MAP_W-50, player.x));
            player.y = Math.max(50, Math.min(MAP_H-50, player.y));

            // Camera
            camera.x = player.x - canvas.width/2;
            camera.y = player.y - canvas.height/2;

            // H·ªìi ph·ª•c & CD
            player.hp = Math.min(player.maxHp, player.hp + 2 * dt);
            player.mp = Math.min(player.maxMp, player.mp + 5 * dt);
            player.atkCD = Math.max(0, player.atkCD - dt);
            for(let i=0; i<3; i++) skillCD[i] = Math.max(0, skillCD[i] - dt);
            talentCD.heal = Math.max(0, talentCD.heal - dt);
            talentCD.flash = Math.max(0, talentCD.flash - dt);

            // X·ª≠ l√Ω AI l√≠nh
            minions.forEach(m => {
                const target = findNearestEnemy(m.x, m.y, m.team === 'blue' ? 'red' : 'blue', 300);
                if (target) {
                    const d = getDist(m.x, m.y, target.x, target.y);
                    if (d > m.range) {
                        const ang = Math.atan2(target.y - m.y, target.x - m.x);
                        m.x += Math.cos(ang) * m.spd; m.y += Math.sin(ang) * m.spd;
                    } else if (m.cd <= 0) {
                        doDamage(target, m.atk); m.cd = 1.0;
                    }
                } else {
                    const goalX = m.team === 'blue' ? MAP_W : 0;
                    const goalY = m.team === 'blue' ? 0 : MAP_H;
                    const ang = Math.atan2(goalY - m.y, goalX - m.x);
                    m.x += Math.cos(ang) * m.spd; m.y += Math.sin(ang) * m.spd;
                }
                m.cd = Math.max(0, m.cd - dt);
            });

            // X·ª≠ l√Ω AI T∆∞·ªõng ƒë·ªãch
            enemies.forEach(e => {
                if (!e.alive) {
                    e.respawn -= dt;
                    if (e.respawn <= 0) { e.alive = true; e.hp = e.maxHp; e.x = MAP_W - 300; e.y = 300; }
                    return;
                }
                const target = findNearestEnemy(e.x, e.y, 'blue', 500);
                if (target) {
                    const d = getDist(e.x, e.y, target.x, target.y);
                    if (d > e.range) {
                        const ang = Math.atan2(target.y - e.y, target.x - e.x);
                        e.x += Math.cos(ang) * e.spd; e.y += Math.sin(ang) * e.spd;
                    } else if (e.cd <= 0) {
                        doDamage(target, e.atk); e.cd = 1.0;
                    }
                }
                e.cd = Math.max(0, e.cd - dt);
            });

            // X·ª≠ l√Ω Tr·ª•
            towers.forEach(t => {
                if (t.hp <= 0) return;
                t.cd -= dt;
                const target = findNearestEnemy(t.x, t.y, t.team === 'blue' ? 'red' : 'blue', t.range);
                if (target && t.cd <= 0) {
                    bullets.push({ x: t.x, y: t.y, tx: target.x, ty: target.y, spd: 10, dmg: t.atk, team: t.team, r: 10, color: t.team==='blue'?'#4a90d9':'#e74c3c' });
                    t.cd = 1.5;
                }
            });

            // X·ª≠ l√Ω ƒê·∫°n
            bullets.forEach(b => {
                const ang = Math.atan2(b.ty - b.y, b.tx - b.x);
                b.x += Math.cos(ang) * b.spd; b.y += Math.sin(ang) * b.spd;
                const targets = getAllEnemies(b.team === 'blue' ? 'red' : 'blue');
                targets.forEach(t => {
                    if (!b.hit && getDist(b.x, b.y, t.x, t.y) < 30) {
                        doDamage(t, b.dmg); b.hit = true;
                    }
                });
            });
            bullets = bullets.filter(b => !b.hit && getDist(b.x, b.y, b.tx, b.ty) > 10);

            // X·ª≠ l√Ω Qu√°i r·ª´ng
            monsters.forEach(m => {
                if (m.hp > 0 && getDist(player.x, player.y, m.x, m.y) < 100 && player.atkCD <= 0) {
                    // T·ª± ƒë·ªông t·∫•n c√¥ng qu√°i n·∫øu ·ªü g·∫ßn
                }
            });

            effects.forEach(e => e.life -= dt);
            effects = effects.filter(e => e.life > 0);

            updateUI();
        }

        // ==================== UTILS ====================
        function getDist(x1, y1, x2, y2) { return Math.sqrt((x2-x1)**2 + (y2-y1)**2); }

        function getAllEnemies(team) {
            let list = [];
            if (team === 'red') {
                enemies.forEach(e => { if(e.alive) list.push(e); });
                minions.forEach(m => { if(m.team === 'red') list.push(m); });
                towers.forEach(t => { if(t.hp > 0 && t.team === 'red') list.push(t); });
                monsters.forEach(m => { if(m.hp > 0) list.push(m); });
            } else {
                if (player.hp > 0) list.push(player);
                minions.forEach(m => { if(m.team === 'blue') list.push(m); });
                towers.forEach(t => { if(t.hp > 0 && t.team === 'blue') list.push(t); });
            }
            return list;
        }

        function findNearestEnemy(x, y, team, maxDist) {
            let best = null, bestD = maxDist;
            getAllEnemies(team).forEach(t => {
                const d = getDist(x, y, t.x, t.y);
                if (d < bestD) { bestD = d; best = t; }
            });
            return best;
        }

        function doDamage(target, dmg) {
            const finalDmg = Math.max(10, dmg - (target.def || 0));
            target.hp -= finalDmg;
            if (target.hp <= 0) {
                if (target.team === 'red' || !target.team) {
                    gold += target.maxHp > 1000 ? 200 : 50;
                    player.exp += 50;
                    if (target.icon && !target.team) { // Monster
                        announce("B·∫†N ƒê√É NH·∫¨N B√ôA!");
                        player.atk += 20;
                    } else if (target.alive !== undefined) { // Enemy hero
                        kills++; blueScore++;
                        announceKill();
                        target.alive = false; target.respawn = 20;
                    }
                    if (target.nexus) endGame(true);
                } else if (target === player) {
                    deaths++; redScore++;
                    announce("B·∫†N ƒê√É B·ªä H·∫† G·ª§C!");
                    player.hp = player.maxHp; player.x = 300; player.y = MAP_H - 300;
                }
                checkLevelUp();
            }
        }

        function announceKill() {
            const now = Date.now();
            if (now - doubleKillTimer < 5000) {
                killCountInTime++;
                if (killCountInTime === 1) announce("DOUBLE KILL!");
                else if (killCountInTime === 2) announce("TRIPLE KILL!");
                else announce("PENTA KILL!!!");
            } else {
                killCountInTime = 0;
                announce("B·∫†N ƒê√É H·∫† T∆Ø·ªöNG ƒê·ªäCH!");
            }
            doubleKillTimer = now;
        }

        function announce(txt) {
            const el = document.getElementById('announcement');
            el.innerText = txt;
            el.style.display = 'block';
            setTimeout(() => el.style.display = 'none', 2000);
        }

        function checkLevelUp() {
            if (player.exp >= player.expNext) {
                player.level++;
                player.exp -= player.expNext;
                player.expNext *= 1.4;
                player.maxHp += 200; player.hp = player.maxHp;
                player.atk += 15;
            }
        }

        function addEffect(x, y, r, color, life) { effects.push({ x, y, r, color, life, maxLife: life }); }

        function updateUI() {
            document.getElementById('hpFill').style.width = (player.hp/player.maxHp*100) + '%';
            document.getElementById('mpFill').style.width = (player.mp/player.maxMp*100) + '%';
            document.getElementById('expFill').style.width = (player.exp/player.expNext*100) + '%';
            document.getElementById('levelText').innerText = 'Lv.' + player.level;
            document.getElementById('goldText').innerText = 'üí∞ ' + gold;
            document.getElementById('blueScore').innerText = blueScore;
            document.getElementById('redScore').innerText = redScore;

            // Cooldown UI
            for(let i=1; i<=3; i++) {
                const btn = document.getElementById('skill'+i);
                if (skillCD[i-1] > 0) btn.classList.add('cooldown');
                else btn.classList.remove('cooldown');
            }
        }

        function endGame(win) {
            gameOver = true;
            document.getElementById('gameOver').style.display = 'flex';
            document.getElementById('resultTitle').innerText = win ? "CHI·∫æN TH·∫ÆNG!" : "TH·∫§T B·∫†I!";
            document.getElementById('resultStats').innerText = `KDA: ${kills}/${deaths} | V√†ng: ${gold}`;
        }

        // ==================== RENDER ====================
        function render() {
            ctx.fillStyle = '#1b4d3e'; // Grass
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Lane
            ctx.strokeStyle = '#3d2b1f'; ctx.lineWidth = 100;
            ctx.beginPath(); ctx.moveTo(300-camera.x, (MAP_H-300)-camera.y);
            ctx.lineTo((MAP_W-300)-camera.x, 300-camera.y); ctx.stroke();

            // Render Entities
            [...towers, ...minions, ...enemies, ...monsters].forEach(e => {
                if (e.hp <= 0 && e.alive === undefined) return;
                if (e.alive === false) return;
                
                const sx = e.x - camera.x, sy = e.y - camera.y;
                if (sx < -100 || sx > canvas.width + 100 || sy < -100 || sy > canvas.height + 100) return;

                ctx.fillStyle = e.team === 'blue' ? '#2e86de' : '#ee5253';
                if (!e.team) ctx.fillStyle = '#f1c40f'; // Monster

                ctx.beginPath(); 
                ctx.arc(sx, sy, e.radius || 30, 0, Math.PI*2); 
                ctx.fill();

                if (e.icon) {
                    ctx.font = '20px Arial'; ctx.textAlign = 'center';
                    ctx.fillText(e.icon, sx, sy + 7);
                }

                // HP Bar
                ctx.fillStyle = '#000'; ctx.fillRect(sx-30, sy-45, 60, 6);
                ctx.fillStyle = e.team === 'blue' ? '#2ecc71' : '#ff4757';
                ctx.fillRect(sx-30, sy-45, (e.hp/e.maxHp)*60, 6);
            });

            // Player
            const px = player.x - camera.x, py = player.y - camera.y;
            ctx.fillStyle = player.color;
            ctx.beginPath(); ctx.arc(px, py, player.radius, 0, Math.PI*2); ctx.fill();
            ctx.font = '20px Arial'; ctx.fillText(player.icon, px, py + 7);

            // Effects & Bullets
            bullets.forEach(b => {
                ctx.fillStyle = b.color;
                ctx.beginPath(); ctx.arc(b.x-camera.x, b.y-camera.y, b.r, 0, Math.PI*2); ctx.fill();
            });

            effects.forEach(e => {
                ctx.globalAlpha = e.life / e.maxLife;
                ctx.strokeStyle = e.color; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(e.x-camera.x, e.y-camera.y, e.r * (2 - e.life/e.maxLife), 0, Math.PI*2); ctx.stroke();
                ctx.globalAlpha = 1;
            });

            renderMinimap();
        }

        function renderMinimap() {
            minimapCtx.fillStyle = '#000'; minimapCtx.fillRect(0,0,100,100);
            const s = 100/MAP_W;
            towers.forEach(t => { if(t.hp>0) { minimapCtx.fillStyle=t.team==='blue'?'#2e86de':'#ee5253'; minimapCtx.fillRect(t.x*s-2, t.y*s-2, 4, 4); }});
            minimapCtx.fillStyle = '#2ecc71'; minimapCtx.beginPath(); minimapCtx.arc(player.x*s, player.y*s, 3, 0, Math.PI*2); minimapCtx.fill();
        }

        function gameLoop(time) {
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;
            if (gameRunning && !gameOver) {
                update(dt);
                render();
            }
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>
